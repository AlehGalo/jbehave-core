<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<title>Configuring Stories</title>
</head>

<body>

<h2>Configuring Stories</h2>

<p>In JBehave, there is a separation of concerns between RunnableStory and Steps classes:</p>
<ul>
    <li><a href="javadoc/core/org/jbehave/core/RunnableStory.html">RunnableStory</a>
    classes are responsible for the configuration of story execution:
    there can be a one-to-one or one-to-may mapping between executable RunnableStory classes
    and textual story files, using <a
            href="javadoc/core/org/jbehave/core/JUnitStory.html">JUnitStory</a> or <a
            href="javadoc/core/org/jbehave/core/JUnitStories.html">JUnitStories</a> respectively.</li>
    <li><a
        href="javadoc/core/org/jbehave/core/steps/Steps.html">Steps</a>
    classes contain the Java methods that match the textual steps in the
    stories: which Steps classes are used when executing a story is
    configured via the RunnableStory class.</li>
</ul>

<p>Even if each executable RunnableStory Java class can be configured
independently, it is good practice to collect the configuration that
applies to all stories in an abstract (i.e. not executable) base
class:</p>
<pre class="brush: java">
public abstract class TraderStory extends JUnitStory {

	public TraderStory() {

		// start with default configuration, overriding only the elements that are needed
        StoryPathResolver storyPathResolver = new UnderscoredCamelCaseResolver(".story");
        Class storyClass = this.getClass();
        Properties rendering = new Properties();
        rendering.put("decorateNonHtml", "true");
        Configuration configuration = new MostUsefulConfiguration()
                .useStoryLoader(new LoadFromClasspath(storyClass.getClassLoader()))
                .useStoryReporterBuilder(new StoryReporterBuilder()
                	// use absolute output directory with Ant
                	//.withOutputDirectory("target/jbehave-reports").withOutputAbsolute(true)
                	.withOutputLocationClass(storyClass)
                	.withDefaultFormats()
                	.withRenderingResources(rendering)
                	.withFormats(CONSOLE, TXT, HTML, XML)
                	.withFailureTrace(false))
                .useStoryPathResolver(storyPathResolver)
                .useStepMonitor(new SilentStepMonitor())
                .useParameterConverters(new ParameterConverters(
        				new TraderConverter(mockTradePersister())))
        		.useStepPatternParser(new RegexPrefixCapturingPatternParser("%"));
        		
		useConfiguration(configuration);
		addSteps(createSteps(configuration));
		
	    configuredEmbedder().embedderControls().doIgnoreFailureInStories(true).doIgnoreFailureInReports(false);

	}

	protected CandidateSteps[] createSteps(Configuration configuration) {
		return new StepsFactory(configuration).createCandidateSteps(
				new TraderSteps(new TradingService()), new BeforeAfterSteps());
	}

}  
</pre>

<p>To run multiple stories, specified as story paths, via a single RunnableStory instance: </p>

<pre class="brush: java">
public class TraderStories extends JUnitStories {

	private URLTraderEmbedder embedder = new URLTraderEmbedder();

	@Override
	protected Embedder configuredEmbedder() {
		return embedder;
	}

	@Override
	protected List<String> storyPaths() {
		return embedder.storyPaths();
	}
</pre>

<p>where the URLTraderEmbedder specifies the story paths:</p>

<pre>
public class URLTraderEmbedder extends ClasspathTraderEmbedder {

	@Override
	public Configuration configuration() {
		return super.configuration().useStoryLoader(new LoadFromURL());
	}

	@Override
	public List<String> storyPaths() {
		// Defining story paths via URLs
		return asList(storyURL("trader_is_alerted_of_status.story"),
				storyURL("traders_can_be_subset.story"));
	}

	private String storyURL(String name) {
		String codeLocation = new StoryLocation("", this.getClass())
				.getCodeLocation().getFile();
		String urlPattern = "file:" + codeLocation
				+ "org/jbehave/examples/trader/stories/{0}";
		return MessageFormat.format(urlPattern, name);

	}

}
</pre>

<span class="followup">Note that in this second example, we are using story paths as URLs, and correspondingly we configure the use of <a
            href="javadoc/core/org/jbehave/core/io/LoadFromURL.html">LoadFromURL</a>.</span>

<p>If we wanted to use an inversion of control container to compose
our Steps with all its dependencies, all we'd need to do is to override
the createSteps method using a different StepsFactory and use that as
your base Story class. For example, to use with a Spring container:</p>
<pre class="brush: java">
public abstract class SpringTraderStory extends TraderStory {

    public SpringTraderStory(Class storyClass) {
        super(storyClass);
    }

    @Override
    protected CandidateSteps[] createSteps(StepsConfiguration configuration) {
        ListableBeanFactory parent = new SpringApplicationContextFactory("org/jbehave/examples/trader/spring/steps.xml")
                                    .getApplicationContext();
        return new SpringStepsFactory(configuration, parent).createCandidateSteps();
    }

}
</pre>

<p>Once we have a base RunnableStory class, all we need to do is to
extend it providing the name of the executable Story class that maps
to the textual story file. For example, to map to <b>trader_is_alerted_of_status.story</b>
using the resolver defined above:</p>
<pre class="brush: java">
public class TraderIsAlertedOfStatus extends TraderStory {

    public TraderIsAlertedOfStatus() {
        super(TraderIsAlertedOfStatus.class);
    }

}
</pre>

<span class="followup">Note that JBehave follow the
configuration-by-convention approach, by which a default value of the
configuration element is provided and can be overridden, if so
desired.</span>

<h3>Story Configuration Elements</h3>

<p>While Stories are designed to be highly configurable, they come
with a default behaviour for the <a
    href="javadoc/core/org/jbehave/core/MostUsefulConfiguration.html">most
useful configuration</a>. <a
    href="javadoc/core/org/jbehave/core/Configuration.html">Configuration</a>
is the main interface for configuring all the components of a story.</p>

<p>The configurable elements of the story include:</p>
<p><a
    href="javadoc/core/org/jbehave/core/steps/StepCollector.html">StepCollector</a>:
Represents the strategy for the collection of executable steps from a given story matching a list of candidate steps. The
default implementation is <a
    href="javadoc/core/org/jbehave/core/steps/MarkUnmatchedStepsAsPending.html">MarkUnmatchedStepsAsPending</a>.</p>
<p><a
    href="javadoc/core/org/jbehave/core/io/StoryParser.html">StoryParser</a>:
Parses stories contained in a textual story file. The
default implementation is <a
    href="javadoc/core/org/jbehave/core/io/RegexStoryParser.html">RegexStoryParser</a>.</p>
<p><a
    href="javadoc/core/org/jbehave/core/reporters/StoryReporter.html">StoryReporter</a>:
Allows the runner to report the state of running stories. The default
implementation is <a
    href="javadoc/core/org/jbehave/core/reporters/ConsoleOutput.html">ConsoleOutput</a>.</p>

<p><a
    href="javadoc/core/org/jbehave/core/errors/ErrorStrategy.html">ErrorStrategy</a>:
Allows to define the strategy for error handling. The default value is <a
    href="javadoc/core/org/jbehave/core/errors/ErrorStrategy.html#RETHROW">RETHROW</a>.</p>

<p><a
    href="javadoc/core/org/jbehave/core/configuration/Keywords.html">Keywords</a>:
Allows to specify the keywords used. The default value is <a
    href="javadoc/core/org/jbehave/core/i18n/LocalizedKeywords.html">LocalizedKeywords</a>.</p>

<p>JBehave provides two useful base implementations that users can
extend to override only the elements that differ from default behaviour:</p>
<p><a
    href="javadoc/core/org/jbehave/core/configuration/MostUsefulConfiguration.html">MostUsefulConfiguration</a>:
provides a default configuration that most users will find appropriate</p>
<p><a
    href="javadoc/core/org/jbehave/core/configuration/PropertyBasedConfiguration.html">PropertyBasedConfiguration</a>:
overrides way to configure via system properties</p>

<h3>Steps Configuration Elements</h3>

<p>Steps can also be configured to a high degree via the <a
    href="javadoc/core/org/jbehave/core/steps/StepsConfiguration.html">StepsConfiguration</a>.
Among the elements that can be configured are:</p>
<p><a
    href="javadoc/core/org/jbehave/core/parsers/StepPatternParser.html">StepPatternParser</a>:
defaults to <a
    href="javadoc/core/org/jbehave/core/parsers/RegexPrefixCapturingPatternBuilder.html">RegexPrefixCapturingPatternParser</a>.</p>
<p><a
    href="javadoc/core/org/jbehave/core/steps/StepMonitor.html">StepMonitor</a>:
defaults to <a
    href="javadoc/core/org/jbehave/core/steps/SilentStepMonitor.html">SilentStepMonitor</a>,
useful to either debug the step matching or to describe the steps being
performed to some output.</p>
<p><a
    href="javadoc/core/org/jbehave/core/steps/ParameterConverters.html">ParameterConverters</a>:
facade for collecting user-defined <a
    href="javadoc/core/org/jbehave/core/steps/ParameterConverters.ParameterConverter.html">ParameterConverters</a>.</p>
<p><a
    href="javadoc/core/org/jbehave/core/configuration/Keywords.html">Keywords</a>:
defaults to <a
    href="javadoc/core/org/jbehave/core/i18n/LocalizedKeywords.html">LocalizedKeywords</a>.</p>

<div class="clear">
<hr />
</div>

</body>
</html>
